\documentclass[draftclsnofoot,onecolumn]{IEEEtran}

\usepackage{graphicx}                                        
\usepackage{amssymb}                                         
\usepackage{amsmath}                                         
\usepackage{amsthm}         


\usepackage{alltt}                                           
\usepackage{float}
\usepackage{color}
\usepackage{url}

\usepackage{balance}
\usepackage[TABBOTCAP, tight]{subfigure}
\usepackage{enumitem}
\usepackage{pstricks, pst-node}

\usepackage{geometry}


\geometry{textheight=8.5in, textwidth=6in}

%random comment

\newcommand{\cred}[1]{{\color{red}#1}}
\newcommand{\cblue}[1]{{\color{blue}#1}}

\usepackage{hyperref}
\usepackage{geometry}

\usepackage{longtable}


\newcommand{\longtableendfoot}{Please continue at the next page}

\def\name{Andrew Chase}

\date{}
\author{\name \\ 
OS II \\
Spring 2015 \\
Abstract: Describes work done to build and run a custom Shortest Seek Time First I/O scheduler.
}
\title{Project 2: I/O Elevators}

%pull in the necessary preamble matter for pygments output
\input{pygments.tex}

%% The following metadata will show up in the PDF properties
\hypersetup{
  colorlinks = true,
  urlcolor = black,
  pdfauthor = {\name},
  pdfkeywords = {cs311 ``operating systems'' files filesystem I/O},
  pdftitle = {CS 311 Project 1: UNIX File I/O},
  pdfsubject = {CS 311 Project 1},
  pdfpagemode = UseNone
}

\begin{document}

\maketitle

\pagebreak

\tableofcontents

\pagebreak

\section{Work Log}

\begin{tabular}{ll}
  \textbf{Date} & \textbf{Work Done} \\
  Apr 26 & Write module, compile and test on os-class. \\
\end{tabular}

\section{Questions}

\subsection{The design you plan to use to implement the SSTF algorithms.}

The original plan I had was to keep the queue alone, and simply seek the queue each time a dispatch happens to find the request closest to the magnetic reader head. I looked through two other solutions posted online (cited in source), I liked the design of the second solution. It was essentially the same as my idea, but at request time instead of dispatch time. When requests were added, the queue is iterated over and the request is put in the lowest position.


\subsection{What do you think the main point of this assignment is?}

I think the main point of the assignment is to use the data structure primitives taught in class and re-enforce some of the I/O scheduler concepts. Although I/O schedulers aren't as important on personal computers as they once were (due to SSDs being more common), the I/O scheduler concepts are still important because they give an example of the kinds of complex problems operating system kernels have to solve efficiently.

\subsection{How did you personally approach the problem? Design decisions, algorithm, etc.}

First I went out and gathered information on the problem and possible solutions. I compared two different solutions to the noop scheduler. One of the two solutions seem to be what I had in mind for how to approach the solution, while the other seemed needlessly complex. 

After I implemented and tested the solution I had in mind, the output from the kernel looked ok, but it seemed wrong. There'd be random jumps down to the first sector number. Then, later, after leaving and doing something else I realized that the solution I had used was wrong. By always sorting the lowest sector first in the queue this ignores the fact that the head might be in a high position.

I went back and changed the algorithm so that the queue is kept sorted by the distance from the last head sector that went to disk. This seemed to return much more correct results in testing.

\subsection{How did you ensure your solution was correct? Testing details, for instance.}

I inserted kprint calls and ran the kernel in the emulator. The kprint calls recorded the sector number.

Example:

\begin{verbatim}
~~~~ 537064
~~~~ 536744
~~~~ 0
~~~~ 4134152
~~~~ 4134248
~~~~ 4456448
~~~~ 4593168
~~~~ 4718592
~~~~ 5505040
\end{verbatim}

The testing helped because the first solution I had implemented wasn't correct and it was pretty obvious to see from the kernel messages. At first, my module didn't load, and using dmesg | grep I was able to find the error message to fix the problem.

\subsection{What did you learn?}

I learned a bit about the noop io scheduler work in linux. How to compile a elevator module and have it run in linux.

\section{Concurrency Exercise: Git Log}

%% This file was generated by the script latex-git-log
\begin{tabular}{lp{20cm}}
  \label{tabular:legend:git-log}
  \textbf{acronym} & \textbf{meaning} \\
  V & \texttt{version} \\
  tag & \texttt{git tag} \\
  MF & Number of \texttt{modified files}. \\
  AL & Number of \texttt{added lines}. \\
  DL & Number of \texttt{deleted lines}. \\
\end{tabular}

\bigskip

\iflanguage{ngerman}{\shorthandoff{"}}{}
\begin{longtable}{|rlllrrr|}
\hline \multicolumn{1}{|c}{\textbf{V}} & \multicolumn{1}{c}{\textbf{tag}}
& \multicolumn{1}{c}{\textbf{date}}
& \multicolumn{1}{c}{\textbf{commit message}} & \multicolumn{1}{c}{\textbf{MF}}
& \multicolumn{1}{c}{\textbf{AL}} & \multicolumn{1}{c|}{\textbf{DL}} \\ \hline
\endhead

\hline \multicolumn{7}{|r|}{\longtableendfoot} \\ \hline
\endfoot

\hline% \hline
\endlastfoot

\hline 1 &  & 2016-04-26 & init & 0 & 144 & 0 \\
\end{longtable}


\section{Code Listing}

\subsection{sstf-iosched.c}

\input{sstf-iosched.c.tex}

\end{document}
